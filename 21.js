const input = '../.. => .../#../#..|#./.. => ###/#.#/.#.|##/.. => ###/.##/##.|.#/#. => .#./..#/...|##/#. => ##./.##/#..|##/## => #.#/###/.##|.../.../... => #.#./.#.#/#.#./###.|#../.../... => #..#/.###/##../##..|.#./.../... => #.##/####/.###/....|##./.../... => ####/.#../#.##/#.##|#.#/.../... => ..../#.../.##./#.##|###/.../... => .###/.#../...#/.#..|.#./#../... => .###/#..#/#.../#...|##./#../... => ..##/...#/#.##/..##|..#/#../... => #.##/.#../...#/..##|#.#/#../... => #.##/..##/..../##.#|.##/#../... => .###/.###/#.../....|###/#../... => #.../####/.#.#/....|.../.#./... => ...#/##.#/...#/###.|#../.#./... => #.#./####/.#../##.#|.#./.#./... => #..#/.##./..##/...#|##./.#./... => ###./#.#./#.../###.|#.#/.#./... => ..#./###./####/.#.#|###/.#./... => .#.#/#..#/..#./#..#|.#./##./... => ####/##../##../..##|##./##./... => #.../..##/#.#./....|..#/##./... => ..../#..#/.#../#..#|#.#/##./... => ###./..##/#.#./#...|.##/##./... => ...#/#..#/####/...#|###/##./... => ..../#.##/###./...#|.../#.#/... => #.../#.../...#/#...|#../#.#/... => ##../#..#/.##./.##.|.#./#.#/... => ##../.###/#.##/#.#.|##./#.#/... => ##.#/.#.#/#.#./..#.|#.#/#.#/... => .##./...#/...#/.#..|###/#.#/... => ####/..#./###./#.##|.../###/... => #..#/.#.#/#.##/..#.|#../###/... => .#../##../##../#.##|.#./###/... => #.#./...#/#.#./#.##|##./###/... => #.#./#..#/.###/.###|#.#/###/... => ..#./...#/..#./#..#|###/###/... => ##../###./####/....|..#/.../#.. => ##../.#../#.#./.##.|#.#/.../#.. => .##./##.#/.#../#...|.##/.../#.. => ####/..#./#..#/##..|###/.../#.. => #.#./..../..#./####|.##/#../#.. => ..##/..##/.##./##..|###/#../#.. => #..#/#..#/.##./.#..|..#/.#./#.. => #..#/#.##/##../#..#|#.#/.#./#.. => .#.#/.#.#/.##./.#.#|.##/.#./#.. => ####/#.##/..../.###|###/.#./#.. => #..#/.#.#/.##./....|.##/##./#.. => ###./##../#..#/....|###/##./#.. => ...#/.#../.#../....|#../..#/#.. => ###./#.../..##/#...|.#./..#/#.. => .#../#.##/.##./..#.|##./..#/#.. => ..#./.##./..../..##|#.#/..#/#.. => #.#./###./.#.#/#..#|.##/..#/#.. => ####/..##/###./.#.#|###/..#/#.. => ##.#/.##./.###/###.|#../#.#/#.. => ..../#.##/.#.#/#..#|.#./#.#/#.. => .###/..../.###/#.##|##./#.#/#.. => ####/..##/#.##/#.##|..#/#.#/#.. => ..#./..##/####/#...|#.#/#.#/#.. => .##./.#.#/.#.#/##..|.##/#.#/#.. => ##.#/##.#/#.##/.###|###/#.#/#.. => #..#/.##./#.##/.###|#../.##/#.. => ####/...#/..##/##..|.#./.##/#.. => .##./#.##/...#/#...|##./.##/#.. => .##./..#./###./....|#.#/.##/#.. => .#.#/##.#/..#./##.#|.##/.##/#.. => ###./####/.##./####|###/.##/#.. => ..#./##.#/.#../..#.|#../###/#.. => ##../#.##/#.../.#.#|.#./###/#.. => ..#./#.##/...#/...#|##./###/#.. => .###/###./.##./###.|..#/###/#.. => #.../..../#.../#...|#.#/###/#.. => .###/...#/...#/..#.|.##/###/#.. => #.#./..../###./.#.#|###/###/#.. => #..#/#.../#.##/##.#|.#./#.#/.#. => .#../##../..##/#.##|##./#.#/.#. => #.##/#.#./#..#/##.#|#.#/#.#/.#. => #..#/.###/..../###.|###/#.#/.#. => #.#./.#.#/####/#.#.|.#./###/.#. => ..##/..#./..##/###.|##./###/.#. => ##../#.#./#.#./.#..|#.#/###/.#. => ####/.##./####/#.#.|###/###/.#. => ####/..#./####/....|#.#/..#/##. => ###./..#./.#../...#|###/..#/##. => #.#./#.##/#..#/##..|.##/#.#/##. => ..../.#../..../....|###/#.#/##. => .###/..#./#.#./####|#.#/.##/##. => ..../.#.#/#.#./...#|###/.##/##. => ##../.#../.#.#/..##|.##/###/##. => ..#./#.#./##../..##|###/###/##. => ..#./###./#.#./..##|#.#/.../#.# => #.#./..../#.##/.#.#|###/.../#.# => #.##/#.../..##/...#|###/#../#.# => ####/.###/..#./.#.#|#.#/.#./#.# => ..#./#..#/#..#/##..|###/.#./#.# => ..../##../.#.#/##.#|###/##./#.# => ..##/..##/.#../####|#.#/#.#/#.# => ####/...#/#.#./#.#.|###/#.#/#.# => #.##/...#/..#./...#|#.#/###/#.# => #.##/####/#..#/..##|###/###/#.# => .##./.##./.##./.#..|###/#.#/### => .#../..../..../.###|###/###/### => #.#./#.#./###./###.'
const initialState = '.#./..#/###'

const LOG = false
const log = LOG ? console.log : () => {}


function toStr(m) {
  return m.map(r => r.join('')).join('/')
}

function generateMatrixPermutations(line, bucket) {
  let [from, to] = line.split(' => ')
  let a = from.split('/').map(x => x.split(''))

  to = to.split('/').map(x => x.split(''))

  // Rotate and flip each input
  for (let i = 0; i < 4; i += 1) {
    // checkDiff(toStr(a), to, bucket)
    bucket[toStr(a)] = to
    a = a.reverse()
    // checkDiff(toStr(a), to, bucket)
    bucket[toStr(a)] = to
    // http://jsfiddle.net/FloydPink/0fg4rLf9/
    for (let i = 0; i < a.length; i++) {
      for (let j = 0; j < i; j++) {
        let temp = a[i][j]
        a[i][j] = a[j][i]
        a[j][i] = temp
      }
    }
  }
}

function expandMatrix(matrix, bucket) {
  let size = matrix.length
  let step = ((size % 2) === 0 ? 2 : 3)
  let expandedSize = step === 2 ? size / 2 * 3 : size / 3 * 4

  const getStr = (m, x, y, step) => {
    if (step === 2) {
      return [
        m[y + 0][x + 0] + m[y + 0][x + 1],
        m[y + 1][x + 0] + m[y + 1][x + 1],
      ].join('/')
    }
    return [
      m[y+0][x+0] + m[y+0][x+1] + m[y+0][x+2],
      m[y+1][x+0] + m[y+1][x+1] + m[y+1][x+2],
      m[y+2][x+0] + m[y+2][x+1] + m[y+2][x+2],
    ].join('/')
  }

  let expandedMatrix = (new Array(expandedSize)).fill(0).map(() => (new Array(expandedSize)).fill(0))

  for (let y = 0; y < size; y += step) {
    for (let x = 0; x < size; x += step) {
      let em = bucket[getStr(matrix, x, y, step)]
      let newX = step === 2 ? x / 2 * 3 : x / 3 * 4
      let newY = step === 2 ? y / 2 * 3 : y / 3 * 4

      em.forEach((row, dy) => {
        row.forEach((c, dx) => {
          expandedMatrix[newY + dy][newX + dx] = c
        })
      })
    }
  }

  return expandedMatrix
}

function countMatrixOn(input, iterations) {
  const bucket = {}
  let matrix = initialState.split('/').map(x => x.split(''))

  // Build lookup bucket
  input.split('|').forEach(line => { generateMatrixPermutations(line, bucket) })

  log(`\n\nBefore expansion\n\n${matrixToStr(matrix)}`)

  // Iteratively expand the matrix
  for (let i = 0; i < iterations; i += 1) {
    matrix = expandMatrix(matrix, bucket)
    log(`\n\nAfter expansion ${i+1}\n\n${matrix.length > 200 ? matrix.length : matrixToStr(matrix)}`)
  }

  return matrix.map(r => r.join('')).join('').split('').filter(x => x === '#').length
}

function matrixToStr(m) {
  return m.map(r => r.join('')).join('\n')
}

if (require.main === module) {
  console.log('Part 1 (on pixels on 5th iteration):', countMatrixOn(input, 5))
  console.log('Part 2 (on pixels on 18th iteration):', countMatrixOn(input, 18))
}

module.exports = {
  countMatrixOn,
}
